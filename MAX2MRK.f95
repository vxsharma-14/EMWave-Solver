!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C 		MAX2MRK- A SOLVER FOR SIMULATING THE INTERACTION OF EM WAVES
!C				 WITH LINEAR, DISPERSIVE OR NON-DISPERSIVE OBJECTS
!C				 IN 2-DIMENSIONS
!C
!C 		VERSION - V1
!C
!C		NUMERICAL SOLVER - 4TH ORDER EXPLICIT MRK-FDFDTD ON 
!C						   CURVILINEAR COORDINATES
!C						   (FD REFERS TO FREQUENCY DEPENDENT METHOD)
!C						   (FDTD REFERS TO STAGGERED SPACE AND TIME GRID 
!C							APPROACH IN TIME-DOMAIN)
!C
!C		BOUNDARY CONDITIONS - PERFECTLY CONDUCTING (PML TO BE ADDED LATER)
!C
!C		MATERIAL MODEL - DISPERSIVE PROPERTIES OF BIOLOGICAL TISSUES
!C						 IS MODELED BY TWO-POLE DEBYE EQUATION (TWO
!C						 RELAXATION CONSTANTS)
!C
!C		EM SOURCE MODEL - 
!C
!C		FILE INPUTS REQUIRED - 
!C
!C		COPYRIGHT 2020 VISHAL SHARMA
!C		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!C						MODULES DECLARATION

MODULE ARRAY

IMPLICIT NONE
SAVE
INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(15, 307) ! COMMAND FOR EXTENDED PRECISION
INTEGER, PARAMETER :: IMAX = 300, JMAX = 300		   ! CHANGE THIS WHEN GRID > 300 POINTS
INTEGER, PARAMETER :: NMAX = 100000
INTEGER, PARAMETER :: FMAX = 500
END MODULE ARRAY


!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							MODULE CHOICE
!C
!C 		MODULE TO DECLARE ACCEPT USER CHOICE VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE CHOICE

USE ARRAY
IMPLICIT NONE
SAVE
INTEGER :: GEOMOPT
INTEGER :: MATOPT
INTEGER :: TFSFOPT
INTEGER :: FFTOPT
INTEGER :: INCOPT
INTEGER :: GRIDOPT
INTEGER :: INITOPT
INTEGER :: NM
INTEGER :: NWRITE
INTEGER :: NDISP
INTEGER :: FRAMOPT
CHARACTER*10 :: EXPNUMBER
CHARACTER*10 :: INITFILE
CHARACTER*10 :: OUTFILE
CHARACTER*10 :: HISTORFILE
REAL(DP) :: CRIT
END MODULE CHOICE

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							MODULE FREESPC
!C
!C 		MODULE TO DECLARE FREE SPACE VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE FREESPC

USE ARRAY
IMPLICIT NONE
SAVE
REAL(DP) :: LREF
REAL(DP) :: E0
REAL(DP) :: MU0
REAL(DP) :: EPS0
REAL(DP) :: SIG0
REAL(DP) :: C

END MODULE FREESPC

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							MODULE DOMAIN
!C
!C 		MODULE TO DECLARE DOMAIN VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE DOMAIN

USE ARRAY
IMPLICIT NONE
SAVE
INTEGER :: IM, JM					! NO. OF GRID POINTS
INTEGER :: I1, I2, J1, J2
INTEGER :: IA, IB, JA, JB			! GRID POINT INDICES TF-SF BOUNDARY
CHARACTER*10 :: FNAME1
CHARACTER*10 :: FNAME2
REAL(DP) :: DX, DY					! GRID SIZE
REAL(DP) :: DXI, DETA
REAL(DP) :: DT						! TIME STEP
REAL(DP) :: A, B					! DIMENSIONS OF DOMAIN
REAL(DP) :: X1, X2, Y1, Y2
REAL(DP) :: RAD
REAL(DP) :: XO, YO
REAL(DP) :: CFL
END MODULE DOMAIN

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							MODULE CURV
!C
!C 		MODULE TO DECLARE COORDINATE TRANSFORMATION VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE CURV

USE ARRAY
IMPLICIT NONE
SAVE
REAL(DP), DIMENSION(IMAX,JMAX) :: X, Y			! GRID POINT COORDINATES
REAL(DP), DIMENSION(IMAX,JMAX) :: XIX, XIY		! TRANSFORMATION METRICS
REAL(DP), DIMENSION(IMAX,JMAX) :: ETAX, ETAY	!			.
REAL(DP), DIMENSION(IMAX,JMAX) :: JJ			! JACOBIAN
END MODULE CURV

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							MODULE MATERIAL
!C
!C 		MODULE TO DECLARE DISPERSIVE MATERIAL PROPERTIES VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE DISPMAT

USE ARRAY
IMPLICIT NONE
SAVE
CHARACTER*10 :: MNAME
REAL(DP) :: MU1M
REAL(DP) :: DSIGSM
REAL(DP) :: EPSS1M, EPSS2M
REAL(DP) :: EPSINFM
REAL(DP) :: DTAU1, DTAU2
REAL(DP) :: TAU1, TAU2
REAL(DP), DIMENSION(IMAX,JMAX) :: MU	! NON-DIMENSIONAL PERMEABILITY
REAL(DP), DIMENSION(IMAX,JMAX) :: EPSS1	! NON-DIMENSIONAL STATIC PERMITTIVITY
REAL(DP), DIMENSION(IMAX,JMAX) :: EPSS2	! NON-DIMENSIONAL STATIC PERMITTIVITY
REAL(DP), DIMENSION(IMAX,JMAX) :: EPSINF! NON-DIMENSIONAL PERMITTIVITY AT INF. FREQ.
REAL(DP), DIMENSION(IMAX,JMAX) :: DSIGS ! DIMENSIONAL STATIC CONDUCTIVITY
REAL(DP), DIMENSION(IMAX,JMAX) :: SUM1,SUM2,SUM3

END MODULE DISPMAT

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							MODULE MATERIAL
!C
!C 		MODULE TO DECLARE NON-DISPERSIVE MATERIAL PROPERTIES
!C		VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE NDISPMAT

USE ARRAY
IMPLICIT NONE
SAVE
REAL(DP) :: MU1
REAL(DP) :: EPS1
REAL(DP) :: DSIG1
REAL(DP), DIMENSION(IMAX,JMAX) :: MU	! NON-DIMENSIONAL PERMEABILITY
REAL(DP), DIMENSION(IMAX,JMAX) :: EPS	! NON-DIMENSIONAL PERMITTIVITY
REAL(DP), DIMENSION(IMAX,JMAX) :: DSIG	! CONDUCTIVITY
END MODULE NDISPMAT

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							MODULE TFIELDS
!C
!C 		MODULE TO DEFINE TOTAL FIELD ELECTROMAGNETIC VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE TFIELDS

USE ARRAY
IMPLICIT NONE
SAVE
REAL(DP), DIMENSION(IMAX,JMAX) :: EZ	! Z-COMPONENT OF E-FIELD
REAL(DP), DIMENSION(IMAX,JMAX) :: DZ	! Z-COMPONENT OF D-FIELD
REAL(DP), DIMENSION(IMAX,JMAX) :: HX	! X-COMPONENT OF H-FIELD
REAL(DP), DIMENSION(IMAX,JMAX) :: HY	! Y-COMPONENT OF H-FIELD
END MODULE TFIELDS

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C								MODULE IFIELDS
!C
!C 		MODULE TO DEFINE INCIDENT FIELD EM VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE IFIELDS

USE ARRAY
IMPLICIT NONE
SAVE
REAL(DP) :: XTFSF1
REAL(DP) :: XTFSF2
REAL(DP) :: YTFSF1
REAL(DP) :: YTFSF2
REAL(DP), DIMENSION(IMAX) :: EZI	! Z-COMPONENT OF E-FIELD
REAL(DP), DIMENSION(IMAX) :: HYI	! Y-COMPONENT OF H-FIELD
END MODULE IFIELDS

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							MODULE FREQVAR
!C
!C 		MODULE TO DEFINE FREQUENCY DOMAIN TOTAL FIELD VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE FREQVAR

USE ARRAY
IMPLICIT NONE
SAVE
INTEGER :: FM
REAL(DP) :: FREQMIN, FREQMAX
REAL(DP), DIMENSION(FMAX) :: FREQ
END FREQVAR

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							MODULE FFIELDS
!C
!C 		MODULE TO DEFINE FREQUENCY DOMAIN FIELD VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE FFIELDS

USE ARRAY
IMPLICIT NONE
SAVE
REAL(DP), DIMENSION(FMAX,IMAX) :: INC_R			! REAL PART OF INCIDENT FIELD
REAL(DP), DIMENSION(FMAX,IMAX) :: INC_I			! IMAG PART OF INCIDENT FIELD
REAL(DP), DIMENSION(FMAX,IMAX,JMAX) :: EZF_R	! REAL PART OF TOTAL E FIELD
REAL(DP), DIMENSION(FMAX,IMAX,JMAX) :: EZF_I	! IMAG PART OF TOTAL E FIELD
END MODULE FFIELDS

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							MODULE INCFFIELDS
!C
!C 		MODULE TO DEFINE FREQUENCY DOMAIN INCIDENT FIELD VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE AMPPH

USE ARRAY
IMPLICIT NONE
SAVE
REAL(DP), DIMENSION(FMAX,IMAX) :: INC_AMP		! FOURIER AMPLITUDE OF INCIDENT FIELD
REAL(DP), DIMENSION(FMAX,IMAX) :: INC_PH		! FOURIER PHASE OF INCIDENT FIELD
REAL(DP), DIMENSION(FMAX,IMAX,JMAX) :: EZF_AMP	! FOURIER AMPLITUDE OF TOTAL E FIELD
REAL(DP), DIMENSION(FMAX,IMAX,JMAX) :: EZF_PH	! FOURIER PHASE OF TOTAL E FIELD
END MODULE AMPPH

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							MODULE SOURCE
!C
!C 		MODULE TO DECLARE SOURCE MODELING VARIABLES
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE SOURCE

USE ARRAY
IMPLICIT NONE
SAVE
INTEGER :: SI, SJ
INTEGER :: DAOPT
REAL(DP) :: TAUW
REAL(DP) :: NT0
REAL(DP) :: AMP
REAL(DP) :: FPEAK
REAL(DP) :: DFPEAK
END MODULE SOURCE

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C																	 
!C								MAIN PROGRAM						 
!C	 															 	 
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PROGRAM MAIN

USE ARRAY
USE CHOICE
USE DOMAIN
USE CURV
IMPLICIT NONE

INTEGER :: N, ITER
REAL(DP) :: DELEZ				! VARIABLES TO STORE STANDARD ERRORS
CHARACTER*2 CF					! CONVERGENCE FLAG

!C*******************************************************************
!C	DISPLAY THE SCHEME											   	*
!C*******************************************************************
    
PRINT*, 'SOLUTION USING MODIFIED RK IN COMPUTATIONAL DOMAIN'
PRINT*

!C*******************************************************************
!C	PREPROCESSING												   	*	
!C*******************************************************************
CALL READUSERINPUT					! READ EXPERIMENT INFO FROM FILE
CALL READGRID  						! READ GRID DATA
! USE THIS ONLY WITH UNIFORM GRID, DXI, DETA SHOULD BE CHANGED TO 1.0 LATER
! ALSO IN GRID GENERATION
A   = X(IM,1)
B   = Y(1,JM)
DXI = (A-X(1,1))/(IM-1)
DETA= (B-Y(1,1))/(JM-1)
DX  = DXI
DY  = DETA
DT  = DXI*CFL

CALL INITIAL(ITER)					! INITIALIZE VARIABLES AND FIELDS
CALL WRITEABOUTFILE					! WRITE ABOUT.DAT FILE WITH EXP. DETAILS
CALL DISPLAYDATA					! DISPLAY EXPERIMENT DETAILS

!C*******************************************************************
!C  ITERATIVE PROCESS												*
!C*******************************************************************
N = ITER
CF='NO'

WRITE(*,*)'ITERATION      ERROR EZ'
WRITE(*,'(I10,3X,A10)')N,'-----'
10 IF(CF.NE.'NO') GOTO 20
     N=N+1
     DELEZ = 0.D0
     CALL MRK(N,JJ,DELEZ)					! SOLVE PDE USING MRK METHOD
     IF(FFTOPT.EQ.1) CALL FOURIERTOTALFIELD	! FOURIER TRANSFORM TOTAL FIELD 
     IF(FFTOPT.EQ.1) CALL FOURIERINCFIELD	! FOURIER TRANSFORM SOURCE FIELD
     WRITE(*,'(I10,3X,E15.8)')N,DELEZ		! DISPLAY ERROR MONITOR
     

     IF((DELEZ.LT.CRIT).AND.(N.GT.1)) THEN	! CHECK CONVERGENCE
       CF='OK'
     ELSE
       IF(N.EQ.NM) THEN
         CF='YS'
         WRITE(*,*)
         WRITE(*,*)'THE CODE HAS REACHED MAX. NUMBER OF ITERATIONS'
       ENDIF
     ENDIF

     IF(MOD(N,NWRITE).EQ.0) CALL WRITETOFILE(N,X,Y,DELEZ,FRAMOPT,OUTFILE,HISTORFILE)

     GOTO 10

20 WRITE(*,*)
WRITE(*,*)'NUMBER OF ITERATIONS, N =',N
CALL WRITETOFILE(N,X,Y,DELEZ,FRAMOPT,OUTFILE,HISTORFILE)
WRITE(*,*)'PROGRAM TERMINATED'

IF (FFTOPT.EQ.1) THEN
  CALL TOTALAMPPHASE
  CALL INCAMPPHASE
  CALL WRITEFFTDATA(N,X,Y)
ENDIF

END PROGRAM MAIN

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							SUBROUTINE READUSERINPUT
!C
!C 		THIS SUBROUTINE READ USER INPUT FROM INPUT FILE - SIMSET.INP
!C
!C 		INPUT: 
!C 		OUTPUT:
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SUBROUTINE READUSERINPUT

USE ARRAY
USE DOMAIN
USE CHOICE
USE FREESPC
IMPLICIT NONE

CHARACTER*10 ENAME

OPEN(UNIT=19,FILE='./INPUT/SIMSET.DAT')
WRITE(*,*) 'READING INPUT FROM FILE "SIMSET.DAT"...'
WRITE(*,*)

READ(19,201)ENAME,EXPNUMBER
201 FORMAT(A10,A10)
IF(ENAME.NE.'EXPERIME') GOTO 200

202 FORMAT(A10,I1)
READ(19,202)ENAME,GEOMOPT
IF((GEOMOPT.NE.1).AND.(GEOMOPT.NE.2)) GOTO 199
IF(ENAME.NE.'GEOMETRY') GOTO 200

READ(19,202)ENAME,MATOPT
IF((MATOPT.NE.1).AND.(MATOPT.NE.2)) GOTO 199
IF(ENAME.NE.'MATERIAL') GOTO 200

READ(19,202)ENAME,TFSFOPT
IF((TFSFOPT.NE.1).AND.(TFSFOPT.NE.2)) GOTO 199
IF(ENAME.NE.'TFSF') GOTO 200

READ(19,202)ENAME,FFTOPT
IF((FFTOPT.NE.1).AND.(FFTOPT.NE.2)) GOTO 199
IF(ENAME.NE.'FOURIER') GOTO 200

READ(19,202)ENAME,INCOPT
IF((INCOPT.NE.1).AND.(INCOPT.NE.2)) GOTO 199
IF(ENAME.NE.'INCIDENT') GOTO 200

READ(19,203)ENAME,CFL
203 FORMAT(A10,5(D10.4))
IF(ENAME.NE.'COURANT') GOTO 200

READ(19,204)ENAME,LREF,E0,MU0,EPS0,SIG0
204 FORMAT(A10,5(D10.4))
IF(ENAME.NE.'REFERENCE') GOTO 200

READ(19,205)ENAME,INITOPT,INITFILE
205 FORMAT(A10,I10,A10)
IF(ENAME.NE.'INIT') GOTO 200

READ(19,206)ENAME,CRIT,NM
206 FORMAT(A10,D10.4,I10)
IF(ENAME.NE.'CONVERG') GOTO 200

READ(19,207)ENAME,NWRITE,OUTFILE,NDISP,HISTORFILE
207 FORMAT(A10,I10,A10,I10,A10)
IF(ENAME.NE.'FILEMAN') GOTO 200

READ(19,208)ENAME,FRAMOPT
IF((FRAMOPT.NE.1).AND.(FRAMOPT.NE.2)) GOTO 199
208 FORMAT(A10,I10)
IF(ENAME.NE.'FRAMESCAP') GOTO 200

!C*******************************************************************
!C	COMPUTE SPEED OF LIGHT											*
!C*******************************************************************
C = 1/DSQRT(MU0*EPS0)

!C*******************************************************************
!C	STOP READING IF ONE RECORD IS MISSING OR WRONG CHOICE IS ENTERED*
!C*******************************************************************
GOTO 1000
199  WRITE(*,*) 'CHECK USER CHOICES OF SIMULATION, ENTER 1 OR 2'
	 WRITE(*,*) 'IN FIELD ',ENAME,' IN INPUT FILE "SIMSET.DAT"'
     STOP
200  WRITE(*,*) ENAME,' RECORD MISSING OR MISPLACED.'
     WRITE(*,*) 'CHECK FILE "SIMSET.DAT"'
     STOP
1000 CLOSE(19)

RETURN
END SUBROUTINE READUSERINPUT

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C								SUBROUTINE READGRID
!C
!C 		THIS SUBROUTINE READ 2D GRID DATA
!C
!C 		INPUT: GRID.DAT
!C 		OUTPUT: X, Y, XIX, XIY, ETAX, ETAY, JJ
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SUBROUTINE READGRID

USE ARRAY
USE CHOICE
USE DOMAIN
USE FREESPC
USE CURV
IMPLICIT NONE

CHARACTER*10 ENAME

INTEGER :: I, J

OPEN(29,FILE='./INPUT/GEOM.DAT')
WRITE(*,*)'READING GRID INPUT DATA FROM  FILE "GEOM.DAT"'
WRITE(*,*)

IF(GEOMOPT.EQ.1) THEN
  READ(29,*)
  
  READ(29,301)ENAME,FNAME1
  301 FORMAT(A10,A10)
  IF(ENAME.NE.'FILE') GOTO 300

  READ(29,302)ENAME,X1,X2
  302 FORMAT(A10,D10.4,D10.4)
  IF(ENAME.NE.'X-BOUND') GOTO 300
    
  READ(29,303)ENAME,Y1,Y2
  303 FORMAT(A10,D10.4,D10.4)
  IF(ENAME.NE.'Y-BOUND') GOTO 300

ELSE

  READ(29,*)
  READ(29,*)
  READ(29,*)
  READ(29,*)
  READ(29,*)
  READ(29,*)

  READ(19,304)ENAME,GRIDOPT
  304 FORMAT(A10,I1)
  IF((GRIDOPT.NE.1).AND.(GRIDOPT.NE.2)) GOTO 299
  IF(ENAME.NE.'CIRCGRID') GOTO 300

  READ(29,305)ENAME,FNAME1,FNAME2
  305 FORMAT(A10,A10,A10)
  IF(ENAME.NE.'FILE') GOTO 300

  READ(29,306)ENAME,RAD
  306 FORMAT(A10,D10.4)
  IF(ENAME.NE.'RADIUS') GOTO 300
    
  READ(29,307)ENAME,XO,YO
  307 FORMAT(A10,D10.4,D10.4)
  IF(ENAME.NE.'ORIGIN') GOTO 300

  READ(29,308)ENAME,I1,I2
  308 FORMAT(A10,I10,I10)
  IF(ENAME.NE.'I-BOUND') GOTO 300

  READ(29,309)ENAME,J1,J2
  309 FORMAT(A10,I10,I10)
  IF(ENAME.NE.'J-BOUND') GOTO 300

ENDIF

!C*******************************************************************
!C	STOP READING IF ONE RECORD IS MISSING OR MISPLACED				*
!C*******************************************************************
GOTO 2000
299  WRITE(*,*) 'CHECK USER CHOICES OF SIMULATION, ENTER 1 OR 2'
	 WRITE(*,*) 'IN FIELD ',ENAME,' IN INPUT FILE "GEOM.DAT"'
     STOP
300  WRITE(*,*) ENAME,' RECORD MISSING OR MISPLACED.'
     WRITE(*,*) 'CHECK FILE "GEOM.DAT"'
     STOP
2000 CLOSE(29)

!C*******************************************************************
!C	READ GRID FILE													*
!C*******************************************************************

IF(GEOMOPT.EQ.1) OPEN(UNIT=39,FILE=FNAME1)
IF((GEOMOPT.EQ.2).AND.(GRIDOPT.EQ.1)) OPEN(UNIT=39,FILE=FNAME1)
IF((GEOMOPT.EQ.2).AND.(GRIDOPT.EQ.2)) OPEN(UNIT=39,FILE=FNAME2)

WRITE(*,*)'READING GRID ...'
WRITE(*,*)
READ(39,*)
READ(39,*)
READ(39,*)
READ(39,310)IM,JM
310 FORMAT(1X,I4,2X,I4)
DO J = 1,JM
  DO I = 1,IM
     
    READ(39,311) X(I,J),Y(I,J),XIX(I,J),XIY(I,J),ETAX(I,J),		&
    			 ETAY(I,J),JJ(I,J)
    X(I,J) = X(I,J)/LREF
    Y(I,J) = Y(I,J)/LREF           
                   
  END DO
END DO
311 FORMAT(1X,D15.7,6(2X,D15.7))
CLOSE(39)

RETURN
END SUBROUTINE READGRID

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							SUBROUTINE INITIAL
!C		SUBROUTINE TO INITIALIZE THE REQUIRED FIELD VARIABLES,
!C		MATERIAL PROPERTIES, AND FREQUENCY DOMAIN VARIABLES
!C
!C		INPUT  : 
!C		OUTPUT : 
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SUBROUTINE INITIAL(ITER)

USE ARRAY
USE CHOICE
USE DOMAIN
USE FREESPC
USE TFIELDS
IMPLICIT NONE

INTEGER :: I, J, ITER

REAL(DP) :: BUF

!C***********************************************************************
!C  WHEN STARTOPT = 2, START FROM PREVIOUS SOLUTION                  	*
!C  THE SOLUTION IS IN DIMENSIONAL FORM: NON-DIMENSIONALIZE THE         * 
!C                      PREVIOUS SOLUTION TO INITIALIZING               *
!C***********************************************************************

IF(INITOPT == 2) THEN
  PRINT*,'RESTARTING FROM PREVIOUS STORED SOLUTION...'
  OPEN(49,FILE=INITFILE)

  PRINT*, 'READING ITER. PERFORMED FROM PREVIOUSLY STORED SOLUTION... '
  READ(49,*)
  READ(49,401)ITER                ! ASSIGNING ITER. VAR. FROM PREVIOUS RUN
  401 FORMAT(1X,I8)

  DO I = 1,IM
    DO J = 1,JM
      READ(49,402) BUF,BUF,DZ(I,J),EZ(I,J),HX(I,J),HY(I,J)
      DZ(I,J)  = DZ(I,J)/E0
      EZ(I,J)  = EZ(I,J)/E0
      HX(I,J)  = HX(I,J)*DSQRT(MU0/EPS0)/E0
      HY(I,J)  = HY(I,J)*DSQRT(MU0/EPS0)/E0
    END DO
  END DO
  402 FORMAT(6(2X,E16.9E3))
  CLOSE(49)

!C***********************************************************************
!C  WHEN STARTOPT = 1, COLD START (INITIALIZE USING INITIAL CONDITIONS) *
!C***********************************************************************   

ELSE
  PRINT*,'INITIALIZING COLD START CONDITIONS...'
  WRITE(*,*)
  ITER = 0                    ! ASSIGNING ITERATION VARIABLE FROM START
  
  DZ(:,:)  = 0.D0
  EZ(:,:)  = 0.D0
  HX(:,:)  = 0.D0
  HY(:,:)  = 0.D0

ENDIF



CALL SRCINIT
IF (MATOPT.EQ.1)CALL NDISPINIT
IF (MATOPT.EQ.2)CALL DISPINIT
IF (TFSFOPT.EQ.1)CALL TFSFINIT
IF (FFTOPT.EQ.1)CALL FFTINIT

RETURN
END INITIAL

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							SUBROUTINE SRCINIT
!C
!C		SUBROUTINE TO INITIALIZE SOURCE VARIABLES
!C
!C 		INPUT: 
!C 		OUTPUT:
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE SRCINIT

USE ARRAY
USE SOURCE
USE CHOICE
USE FREESPC

IMPLICIT NONE

CHARACTER*10 :: ENAME

WRITE(*,*) 'READING SOURCE DATA...'
WRITE(*,*)
OPEN(59,FILE='./INPUT/SOURCE.DAT')

READ(59,501)ENAME,SI,SJ
501 FORMAT(A10,I10,I10)
IF(ENAME.NE.'SOURCELOC') GOTO 500

READ(59,502)ENAME,DAOPT
502 FORMAT(A10,I10,I10)
IF((DAOPT.NE.1).AND.(DAOPT.NE.2)) GOTO 499
IF(ENAME.NE.'DIPOLEANT') GOTO 500

IF(INCOPT.EQ.1) THEN
  READ(59,*)
  READ(59,*)
  READ(59,503)ENAME,TAUW
  503 FORMAT(A10,D10.4)
  IF(ENAME.NE.'WIDTH') GOTO 500

  READ(59,504)ENAME,NT0
  504 FORMAT(A10,D10.4)
  IF(ENAME.NE.'DELAY') GOTO 500

  READ(59,505)ENAME,AMP
  505 FORMAT(A10,D10.4)
  IF(ENAME.NE.'AMPLITUDE') GOTO 500

ELSE
  READ(59,*)
  READ(59,*)
  READ(59,*)
  READ(59,*)
  READ(59,*)
  READ(59,*)
  READ(59,*)
  READ(59,*)
  READ(59,*)
  READ(59,506)ENAME,DFPEAK
  506 FORMAT(A10,D10.4)
  IF(ENAME.NE.'PEAKFREQ') GOTO 500

  READ(59,507)ENAME,NT0
  507 FORMAT(A10,D10.4)
  IF(ENAME.NE.'AMPLITUDE') GOTO 500

  FPEAK=DFPEAK*LREF/C
ENDIF

!C*******************************************************************
!C	STOP READING IF ONE RECORD IS MISSING OR MISPLACED				*
!C*******************************************************************
GOTO 3000
499  WRITE(*,*) 'CHECK USER CHOICES OF SIMULATION, ENTER 1 OR 2'
	 WRITE(*,*) 'IN FIELD ',ENAME,' IN INPUT FILE "SOURCE.DAT"'
     STOP
500  WRITE(*,*) ENAME,' RECORD MISSING OR MISPLACED.'
     WRITE(*,*) 'CHECK FILE "SOURCE.DAT"'
     STOP
3000 CLOSE(59)

RETURN
END SUBROUTINE SRCINIT

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							SUBROUTINE NDISPINIT
!C
!C		IF MATOPT==1 FREQEUNCY INDEPENDENT (NON-DISPERSIVE) MATERIAL
!C		SUBROUTINE TO INITIALIZE NON-DISPERSIVE MATERIAL PROPERTIES
!C		EVERYWHERE
!C
!C  	INPUT  :
!C		OUTPUT :
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SUBROUTINE NDISPINIT

USE ARRAY
USE DOMAIN
USE FREESPC
USE CHOICE
USE NDISPMAT
IMPLICIT NONE

INTEGER :: I, J
INTEGER :: IO, JO
CHARACTER*10 :: ENAME
REAL(DP) :: XDIST, YDIST, DIST

WRITE(*,*) 'READING NON-DISPERSIVE MATERIAL PROPERTIES...'
WRITE(*,*)
OPEN(69,FILE='./INPUT/MATPROP.DAT')
READ(69,*)

READ(69,601)ENAME,MU1
601 FORMAT(A10,D10.4)
IF(ENAME.NE.'PERME') GOTO 600

READ(69,602)ENAME,EPS1
602 FORMAT(A10,D10.4)
IF(ENAME.NE.'PERMI') GOTO 600

READ(69,603)ENAME,DSIG1
603 FORMAT(A10,D10.4)
IF(ENAME.NE.'COND') GOTO 600

MU(:,:)   = MU0/MU0
EPS(:,:)  = EPS0/EPS0
DSIG(:,:) = 0.D0

IF(GEOMOPT.EQ.1) THEN
  I1 = IDNINT(DBLE(X1/DX)+1)
  I2 = IDNINT(DBLE(X2/DX)+1)
  J1 = IDNINT(DBLE(Y1/DY)+1)
  J2 = IDNINT(DBLE(Y2/DY)+1)
  DO I = I1,I2
    DO J = J1,J2
      MU(I,J)   = MU1
      EPS(I,J)  = EPS1
      DSIG(I,J) = DSIG1
    END DO
  END DO
ELSE
  IF(GRIDOPT.EQ.1) THEN
    DO I = I1,I2
      DO J = J1,J2
        MU(I,J)   = MU1
        EPS(I,J)  = EPS1
        DSIG(I,J) = DSIG1
      END DO
    END DO
  ELSE
    IO = IDNINT(DBLE(XO/DX)) + 1
	JO = IDNINT(DBLE(YO/DX)) + 1
    DO I = 1,IM
      XDIST = (IO - I)*DX
      DO J = 1,JM
        YDIST = (JO - J)*DY
        DIST  = DSQRT(XDIST**2 + YDIST**2)
        IF(DIST.LE.RAD) THEN
          MU(I,J)   = MU1
          EPS(I,J)  = EPS1
          DSIG(I,J) = DSIG1
        ENDIF
      END DO
    END DO
  ENDIF
ENDIF

!C*******************************************************************
!C	STOP READING IF ONE RECORD IS MISSING OR MISPLACED				*
!C*******************************************************************
GOTO 4000
600  WRITE(*,*) ENAME,' RECORD MISSING OR MISPLACED.'
     WRITE(*,*) 'CHECK FILE "MATPROP"'
     STOP
4000 CLOSE(69)
      
RETURN
END SUBROUTINE NDISPINIT

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							SUBROUTINE DISPINIT
!C		IF MATOPT==2 FREQEUNCY DEPENDENT (DISPERSIVE) MATERIAL
!C
!C		SUBROUTINE TO INITIALIZE DISPERSIVE MATERIAL PROPERTIES
!C		EVERYWHERE
!C
!C  	INPUT  :
!C		OUTPUT :
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SUBROUTINE DISPINIT

USE ARRAY
USE DOMAIN
USE CHOICE
USE FREESPC
USE DISPMAT
IMPLICIT NONE

INTEGER :: I, J
INTEGER :: IO, JO
CHARACTER*10 :: ENAME
REAL(DP) :: XDIST, YDIST, DIST

WRITE(*,*) 'READING DISPERSIVE MATERIAL PROPERTIES...'
WRITE(*,*)
OPEN(79,FILE='./INPUT/MATPROP.DAT')
READ(79,*)
READ(79,*)
READ(79,*)
READ(79,*)
READ(79,*)
READ(79,*)

READ(79,701)ENAME,MNAME
701 FORMAT(A10,A10)
IF(ENAME.NE.'NAME') GOTO 700

READ(79,702)ENAME,MU1M
702 FORMAT(A10,D10.4)
IF(ENAME.NE.'PERME') GOTO 700

READ(79,703)ENAME,EPSS1M,EPSS2M
703 FORMAT(A10,D10.4,D10.4)
IF(ENAME.NE.'PERMSTAT') GOTO 700

READ(79,704)ENAME,EPSINFM
704 FORMAT(A10,D10.4)
IF(ENAME.NE.'PERMINF') GOTO 700

READ(79,705)ENAME,DTAU1,DTAU2
705 FORMAT(A10,D10.4,D10.4)
IF(ENAME.NE.'RELAXC') GOTO 700

READ(79,706)ENAME,DSIGSM
706 FORMAT(A10,D10.4)
IF(ENAME.NE.'CONDSTAT') GOTO 700

MU(:,:)     = MU0/MU0
EPSS1(:,:)  = EPS0/EPS0
EPSS2(:,:)  = EPS0/EPS0
EPSINF(:,:) = EPS0/EPS0
DSIGS(:,:)  = 0.D0
SUM1(:,:)	= 0.D0
SUM2(:,:)   = 0.D0
SUM3(:,:)   = 0.D0


IF(GEOMOPT.EQ.1) THEN
  I1 = IDNINT(DBLE(X1/DX)+1)
  I2 = IDNINT(DBLE(X2/DX)+1)
  J1 = IDNINT(DBLE(Y1/DY)+1)
  J2 = IDNINT(DBLE(Y2/DY)+1)
  DO I = I1,I2
    DO J = J1,J2
      MU(I,J)	  = MU1M
      EPSS1(I,J)  = EPSS1M
      EPSS2(I,J)  = EPSS2M
      EPSINF(I,J) = EPSINFM
      DSIGS(I,J)  = DSIGSM
    END DO
  END DO
ELSE
  IF(GRIDOPT.EQ.1) THEN
    DO I = I1,I2
      DO J = J1,J2
        MU(I,J)	    = MU1M
        EPSS1(I,J)  = EPSS1M
        EPSS2(I,J)  = EPSS2M
        EPSINF(I,J) = EPSINFM
        DSIGS(I,J)  = DSIGSM
      END DO
    END DO
  ELSE
    IO = IDNINT(DBLE(XO/DX)) + 1
	JO = IDNINT(DBLE(YO/DX)) + 1
    DO I = 1,IM
      XDIST = (IO - I)*DX
      DO J = 1,JM
        YDIST = (JO - J)*DY
        DIST  = DSQRT(XDIST**2 + YDIST**2)
        IF(DIST.LE.RAD) THEN
          MU(I,J)	  = MU1M
          EPSS1(I,J)  = EPSS1M
          EPSS2(I,J)  = EPSS2M
          EPSINF(I,J) = EPSINFM
          DSIGS(I,J)  = DSIGSM
        ENDIF
      END DO
    END DO
  ENDIF
ENDIF
TAU1 = DTAU1*C/LREF
TAU2 = DTAU2*C/LREF

!C*******************************************************************
!C	STOP READING IF ONE RECORD IS MISSING OR MISPLACED				*
!C*******************************************************************
GOTO 5000
700  WRITE(*,*) ENAME,' RECORD MISSING OR MISPLACED.'
     WRITE(*,*) 'CHECK FILE "MATPROP.DAT"'
     STOP
5000 CLOSE(79)

RETURN
END SUBROUTINE DISPINIT

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							SUBROUTINE TFSFINIT
!C
!C 		IF TFSFOPT==1 TOTAL FIELD-SCATTERED FIELD FORMULATION
!C		SUBROUTINE TO INITIALIZE VARIABLES FOR INCIDENT FIELD
!C		EVERYWHERE
!C
!C 		INPUT: 
!C 		OUTPUT:
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE TFSFINIT

USE ARRAY
USE DOMAIN
USE IFIELDS

IMPLICIT NONE

CHARACTER*10 :: ENAME

WRITE(*,*)'INITIALIZING INCIDENT FIELDS'
WRITE(*,*)
EZI(:) = 0.D0
HYI(:) = 0.D0

WRITE(*,*) 'SETTING TOTAL FIELD SCATTERED FIELD BOUNDARIES...'
WRITE(*,*)
OPEN(89,FILE='./INPUT/TFSF.DAT')

READ(89,801)ENAME,XTFSF1,XTFSF2
801 FORMAT(A10,D10.4,D10.4)
IF(ENAME.NE.'XBOUNDARY') GOTO 800

READ(89,802)ENAME,YTFSF1,YTFSF2
802 FORMAT(A10,D10.4,D10.4)
IF(ENAME.NE.'YBOUNDARY') GOTO 800

IA = XTFSF1/DXI+1
IB = XTFSF2/DXI+1
JA = YTFSF1/DETA+1
JB = YTFSF2/DETA+1
!C*******************************************************************
!C	STOP READING IF ONE RECORD IS MISSING OR MISPLACED				*
!C*******************************************************************
GOTO 6000
800  WRITE(*,*) ENAME,' RECORD MISSING OR MISPLACED.'
     WRITE(*,*) 'CHECK FILE "TFSF.DAT"'
     STOP
6000 CLOSE(89)

RETURN
END SUBROUTINE TFSFINIT

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							SUBROUTINE FFTINIT
!C
!C 		IF FFTOPT==1 FAST FOURIER TRANSFORM IS PERFORMED
!C		SUBROUTINE TO INITIALIZE VARIABLES FOR FREQUENCY DOMAIN DATA
!C		EVERYWHERE
!C
!C 		INPUT: 
!C 		OUTPUT:
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE FFTINIT

USE ARRAY
USE FREESPC
USE FREQVAR
USE FFIELDS

IMPLICIT NONE

INTEGER :: F
CHARACTER*10 :: ENAME
REAL(DP) :: DF

WRITE(*,*) 'INITIALIZING  FREQUENCY DOMAIN DATA...'
WRITE(*,*)
OPEN(99,FILE='./INPUT/FFT.DAT')

READ(99,901)ENAME,FREQMIN,FREQMAX
901 FORMAT(A10,D10.4,D10.4)
IF(ENAME.NE.'FREQRANGE') GOTO 900

READ(99,902)ENAME,FM
902 FORMAT(A10,I10)
IF(ENAME.NE.'FREPOINTS') GOTO 900

FREQ(1) = FREQMIN
FREQ(FM)= FREQMAX
DF = (FREQMAX - FREQMIN)/(FM - 1)
DO F = 2,FM-1
  FREQ(F) = DF*(F - 1)*LREF/C
END DO

INC_R(:,:) = 0.D0			! REAL PART OF INCIDENT FIELD IN FREQ. DOMAIN
INC_I(:,:) = 0.D0			! IMAG PART OF INCIDENT FIELD IN FREQ. DOMAIN
EZF_R(:,:,:) = 0.D0			! REAL PART OF TOTAL FIELD IN FREQ. DOMAIN
EZF_I(:,:,:) = 0.D0			! IMAG PART OF TOTAL FIELD IN FREQ DOMAIN

!C*******************************************************************
!C	STOP READING IF ONE RECORD IS MISSING OR MISPLACED				*
!C*******************************************************************
GOTO 7000
900  WRITE(*,*) ENAME,' RECORD MISSING OR MISPLACED.'
     WRITE(*,*) 'CHECK FILE "FFT.DAT"'
     STOP
7000 CLOSE(99)

RETURN
END SUBROUTINE FFTINIT

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							SUBROUTINE DISPLAYDATA
!C		 
!C		THIS SUBROUTINE DISPLAYS THE EXPERIMENT SETUP TO OUTPUT SCREEN
!C
!C 		INPUT: 
!C 		OUTPUT:
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SUBROUTINE DISPLAYDATA

USE ARRAY
USE DOMAIN
USE CHOICE
USE FREESPC
USE DISPMAT
USE NDISPMAT
USE FREQVAR
USE SOURCE
IMPLICIT NONE

WRITE(*,'(A25,A10)')'EXPERIMENT #             ',EXPNUMBER
WRITE(*,*)
IF(MATOPT.EQ.1) THEN
  WRITE(*,'(A25,A14)')'MATERIAL TYPE            ','NON-DISPERSIVE'
ELSE
  WRITE(*,'(A25,A10)')'MATERIAL TYPE            ','DISPERSIVE'
ENDIF
WRITE(*,'(A25,F4.2,6X,F4.2,2X,A3)')'DOMAIN DIMENSIONS        ',A,B,'M^2'
WRITE(*,'(A25,I4,6X,I4)')'NO. OF GRID POINTS       ',IM,JM
WRITE(*,'(A25,F6.4,4X,F6.4)')'GRID STEP                ',DX,DY
WRITE(*,'(A25,F6.4)')'TIME STEP                ',DT
WRITE(*,'(A25,F4.2)')'COURANT NUMBER           ',CFL
WRITE(*,*)
WRITE(*,*)'======================================================='
WRITE(*,*)'GEOMETRY SPECIFICATION'
WRITE(*,*)'======================================================='
IF(GEOMOPT.EQ.1) THEN
  WRITE(*,'(A25,A6)')'GEOMETRY                 ','SQUARE'
  WRITE(*,'(A25,F4.2,1X,A2,1X,F4.2,1X,A1)')'LENGTH, HEIGHT           ',X2-X1,'M,',Y2-Y1,'M'
ELSE
  WRITE(*,'(A25,A8)')'GEOMETRY                 ','CIRCULAR'
  WRITE(*,'(A25,F4.2,1X,A1)')'RADIUS',RAD,'M'
  IF(GRIDOPT.EQ.1) THEN
    WRITE(*,'(A25,A23)')'CURVED BOUNDARIES        ','FITTED WITH GRID POINTS'
  ELSE
    WRITE(*,'(A25,A23)')'CURVED BOUNDARIES        ','APPROXIMATED BY STAIRCASING'
  ENDIF
ENDIF
WRITE(*,*)
IF(TFSFOPT.EQ.1) THEN
  WRITE(*,'(A25,A3)')'TOTAL F SCATTERED F      ','YES'
ELSE
  WRITE(*,'(A25,A2)')'TOTAL F SCATTERED F      ','NO'
ENDIF
IF(FFTOPT.EQ.1) THEN
  WRITE(*,'(A25,A3)')'FREQUENCY DOMAIN DATA    ','YES'
ELSE
  WRITE(*,'(A25,A2)')'FREQUENCY DOMAIN DATA    ','NO'
ENDIF
WRITE(*,*)
IF(INCOPT.EQ.1) THEN
  WRITE(*,'(A25,A14)')'SOURCE WAVEFORM          ','GAUSSIAN PULSE'
  IF(FFTOPT.EQ.1)WRITE(*,'(A25,E10.4,1X,A2,1X,E10.4,1X,A2)')'FREQUENCY RANGE          ',FREQMIN,'TO',FREQMAX,'HZ'
ELSE
  WRITE(*,'(A25,A9)')'SOURCE WAVEFORM          ','SINE WAVE'
  WRITE(*,'(A25,E10.4,1X,A2)')'PEAK FREQUENCY           ',FPEAK,'HZ'
ENDIF
WRITE(*,*)
WRITE(*,*)'========================================================'
WRITE(*,*)'MATERIAL PROPERTIES'
WRITE(*,*)'========================================================'
IF(MATOPT.EQ.1) THEN
  WRITE(*,'(A25,E10.4)')'DIELECTRIC PERMITTIVITY  ',EPS1
  WRITE(*,'(A25,E10.4)')'PERMEABILITY             ',MU1
  WRITE(*,'(A25,E10.4,1X,A3)')'CONDUCTIVITY             ',DSIG1,'S/M'
ELSE
  WRITE(*,'(A25,A10)')'MATERIAL NAME            ',MNAME
  WRITE(*,'(A25,E10.4)')'STATIC PERMITTIVITY 1    ',EPSS1M
  WRITE(*,'(A25,E10.4)')'STATIC PERMITTIVITY 2    ',EPSS2M
  WRITE(*,'(A25,E10.4)')'PERMITTIVITY AT INF FREQ ',EPSINFM
  WRITE(*,'(A25,E10.4,1X,A3)')'RELAXATION TIME CONST 1  ',DTAU1,'SEC'
  WRITE(*,'(A25,E10.4,1X,A3)')'RELAXATION TIME CONST 2  ',DTAU2,'SEC'
  WRITE(*,'(A25,E10.4)')'PERMEABILITY             ',MU1M
  WRITE(*,'(A25,E10.4)')'STATIC CONDUCTIVITY      ',DSIGSM
ENDIF
WRITE(*,*)
WRITE(*,*)'INITIALIZATION DONE'

RETURN
END SUBROUTINE DISPLAYDATA

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C					    	SUBROUTINE WRITEABOUT
!C
!C
!C 		INPUT: 
!C 		OUTPUT:
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SUBROUTINE WRITEABOUTFILE

USE ARRAY
USE DOMAIN
USE CHOICE
USE FREESPC
USE DISPMAT
USE NDISPMAT
USE FREQVAR
USE SOURCE
IMPLICIT NONE

OPEN(109,FILE='./OUTPUT/ABOUT.TXT')
WRITE(109,'(A25,A10)')'EXPERIMENT #             ',EXPNUMBER
WRITE(109,*)
IF(MATOPT.EQ.1) THEN
  WRITE(109,'(A25,A14)')'MATERIAL TYPE            ','NON-DISPERSIVE'
ELSE
  WRITE(109,'(A25,A10)')'MATERIAL TYPE            ','DISPERSIVE'
ENDIF
WRITE(109,'(A25,F4.2,6X,F4.2,2X,A3)')'DOMAIN DIMENSIONS        ',A,B,'M^2'
WRITE(109,'(A25,I4,6X,I4)')'NO. OF GRID POINTS       ',IM,JM
WRITE(109,'(A25,F6.4,4X,F6.4)')'GRID STEP                ',DX,DY
WRITE(109,'(A25,F6.4)')'TIME STEP                ',DT
WRITE(109,'(A25,F4.2)')'COURANT NUMBER           ',CFL
WRITE(109,*)
WRITE(109,*)'======================================================='
WRITE(109,*)'GEOMETRY SPECIFICATION'
WRITE(109,*)'======================================================='
IF(GEOMOPT.EQ.1) THEN
  WRITE(109,'(A25,A6)')'GEOMETRY                 ','SQUARE'
  WRITE(109,'(A25,F4.2,1X,A2,1X,F4.2,1X,A1)')'LENGTH, HEIGHT           ',X2-X1,'M,',Y2-Y1,'M'
ELSE
  WRITE(109,'(A25,A8)')'GEOMETRY                 ','CIRCULAR'
  WRITE(109,'(A25,F4.2,1X,A1)')'RADIUS',RAD,'M'
  IF(GRIDOPT.EQ.1) THEN
    WRITE(109,'(A25,A23)')'CURVED BOUNDARIES        ','FITTED WITH GRID POINTS'
  ELSE
    WRITE(109,'(A25,A23)')'CURVED BOUNDARIES        ','APPROXIMATED BY STAIRCASING'
  ENDIF
ENDIF
WRITE(109,*)
IF(TFSFOPT.EQ.1) THEN
  WRITE(109,'(A25,A3)')'TOTAL F SCATTERED F      ','YES'
ELSE
  WRITE(109,'(A25,A2)')'TOTAL F SCATTERED F      ','NO'
ENDIF
IF(FFTOPT.EQ.1) THEN
  WRITE(109,'(A25,A3)')'FREQUENCY DOMAIN DATA    ','YES'
ELSE
  WRITE(109,'(A25,A2)')'FREQUENCY DOMAIN DATA    ','NO'
ENDIF
WRITE(109,*)
IF(INCOPT.EQ.1) THEN
  WRITE(109,'(A25,A14)')'SOURCE WAVEFORM          ','GAUSSIAN PULSE'
  IF(FFTOPT.EQ.1)WRITE(109,'(A25,E10.4,1X,A2,1X,E10.4,1X,A2)')'FREQUENCY RANGE          ',FREQMIN,'TO',FREQMAX,'HZ'
ELSE
  WRITE(109,'(A25,A9)')'SOURCE WAVEFORM          ','SINE WAVE'
  WRITE(109,'(A25,E10.4,1X,A2)')'PEAK FREQUENCY           ',FPEAK,'HZ'
ENDIF
WRITE(109,*)
WRITE(109,*)'========================================================'
WRITE(109,*)'MATERIAL PROPERTIES'
WRITE(109,*)'========================================================'
IF(MATOPT.EQ.1) THEN
  WRITE(109,'(A25,E10.4)')'DIELECTRIC PERMITTIVITY  ',EPS1
  WRITE(109,'(A25,E10.4)')'PERMEABILITY             ',MU1
  WRITE(109,'(A25,E10.4,1X,A3)')'CONDUCTIVITY             ',DSIG1,'S/M'
ELSE
  WRITE(109,'(A25,A10)')'MATERIAL NAME            ',MNAME
  WRITE(109,'(A25,E10.4)')'STATIC PERMITTIVITY 1    ',EPSS1M
  WRITE(109,'(A25,E10.4)')'STATIC PERMITTIVITY 2    ',EPSS2M
  WRITE(109,'(A25,E10.4)')'PERMITTIVITY AT INF FREQ ',EPSINFM
  WRITE(109,'(A25,E10.4,1X,A3)')'RELAXATION TIME CONST 1  ',DTAU1,'SEC'
  WRITE(109,'(A25,E10.4,1X,A3)')'RELAXATION TIME CONST 2  ',DTAU2,'SEC'
  WRITE(109,'(A25,E10.4)')'PERMEABILITY             ',MU1M
  WRITE(109,'(A25,E10.4)')'STATIC CONDUCTIVITY      ',DSIGSM
ENDIF

CLOSE(109)

RETURN
END SUBROUTINE WRITEABOUTFILE

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C					    	SUBROUTINE BC
!C
!C		THIS SUBROUTINE SETS BOUNDARY CONDITIONS (DIRICHLET BC)
!C
!C 		INPUT  : NONE
!C 		OUTPUT : DZ, HX, HY
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SUBROUTINE BC(DZ,HX,HY)
        
USE ARRAY
USE DOMAIN
IMPLICIT NONE

INTEGER :: I, J
        
REAL(DP), DIMENSION(IMAX,JMAX) :: DZ, HX, HY

DO I = 1,IM
  DZ(I,1) = 0.D0
  HX(I,1) = 0.D0
  HY(I,1) = 0.D0

  DZ(I,JM) = 0.D0
  HX(I,JM) = 0.D0
  HY(I,JM) = 0.D0
END DO

DO J = 1,JM
  DZ(1,J) = 0.D0
  HX(1,J) = 0.D0
  HY(1,J) = 0.D0

  DZ(IM,J) = 0.D0
  HX(IM,J) = 0.D0
  HY(IM,J) = 0.D0
END DO

RETURN
END SUBROUTINE BC

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE DZTOEZ
!C
!C		THIS SUBROUTINE COMPUTES E-FIELDS FROM D-FIELDS
!C
!C 		INPUT  : DZ, EPSS1, EPSS2, EPSINF, DSIGS 
!C 		OUTPUT : EZ
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SUBROUTINE DZTOEZ(DZ,EZ)

USE DOMAIN
USE SOURCE
USE DISPMAT
USE FREESPC

IMPLICIT NONE

INTEGER :: I, J
REAL(DP) :: DEN2_1, DEN2_2, COND
REAL(DP) :: DEPSS1, DEPSS2
REAL(DP), DIMENSION(IMAX,JMAX) :: DEN2, COEFF
REAL(DP), DIMENSION(IMAX,JMAX) :: EZ, DZ

!C***********************************************************************
!C	EVALUATE THE COEFFICIENT TERM USED IN THE EZ EQUATION				*
!C***********************************************************************
DO I = 1,IM
  DO J = 1,JM
    DEPSS1 = EPSS1(I,J)-EPSINF(I,J)	! DELTA EPS. FOR RELAXATION TERM 1
    DEPSS2 = EPSS2(I,J)-EPSINF(I,J)	! DELTA EPS. FOR RELAXATION TERM 2

    DEN2_1 = DEPSS1*DT/TAU1   	! 2ND TERM IN DENOMINATOR, POLE 1
    DEN2_2 = DEPSS2*DT/TAU2		! 2ND TERM IN DENOMINATOR, POLE 2
    DEN2(I,J) = DEN2_1+DEN2_2	! 2ND TERM IN DENOMINATOR SUMMATION

    COND = DSIGS(I,J)*DT/EPS0	! 3RD TERM IN DENOMINATOR
    
!C	COEFFICIENT IN EZ COMPUTATION
    COEFF(I,J) = 1.D0/(EPSINF(I,J)+DEN2(I,J)+COND)
  END DO
END DO

!C***********************************************************************
!C	THE BELOW FORMULATION WILL MODEL THE DIPOLE ANTENNA					*
!C  IT WILL ENSURE THAT THE FIELD IS ZERO IN THE ANTENNA ARMS AND		*
!C  FIELD EXISTS ONLY AT THE GAP SI,SJ									*
!C***********************************************************************

IF(DAOPT.EQ.1) THEN
  DO J = SJ-20,SJ+20
    COEFF(SI,J) = 0.D0
  END DO
  COEFF(SI,SJ) = 1.D0
ENDIF

!C***********************************************************************
!C	EVALUATE EZ USING THE DERIVED FORMULATION							*
!C***********************************************************************

DO I = 1,IM
  DO J = 1,JM
    EZ(I,J) = COEFF(I,J)*(DZ(I,J)-SUM1(I,J)-SUM2(I,J)-SUM3(I,J))
    !C POLE 1 OF THE DEBYE EQUATION
    SUM1(I,J) = SUM1(I,J)*DEXP(-DT/TAU1) + (EPSS1(I,J) - 			&
       			EPSINF(I,J))*DT*EZ(I,J)/TAU1
    !C POLE 2 OF THE DEBYE EQUATION
    SUM2(I,J) = SUM2(I,J)*DEXP(-DT/TAU2) + (EPSS2(I,J) - 			&
       			EPSINF(I,J))*DT*EZ(I,J)/TAU2
    ! 3RD TERM IN NUMERATOR
    SUM3(I,J) = SUM3(I,J) + DSIGS(I,J)*DT*EZ(I,J)/EPS0
  END DO
END DO

RETURN
END SUBROUTINE DZTOEZ
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE FLUXPQ
!C
!C		THIS SUBROUTINE COMPUTES FLUX VECTORS P AND Q FROM 
!C		E AND H FIELDS
!C
!C 		INPUT  : EZ, HX, HY
!C 		OUTPUT : P1, P2, P3, Q1, Q2, Q3
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE FLUXPQ(EZ,HX,HY,P1,P2,P3,Q1,Q2,Q3)

USE ARRAY
USE CURV
USE DOMAIN
IMPLICIT NONE

INTEGER :: I, J

REAL(DP), DIMENSION(IMAX,JMAX) :: P1, P2, P3, Q1, Q2, Q3
REAL(DP), DIMENSION(IMAX,JMAX) :: EZ, HX, HY

REAL(DP) :: PP1, PP2, PP3, QP1, QP2, QP3

DO I = 1,IM
  DO J = 1,JM
!C***********************************************************************
!C 	 EVALUATION OF THE FLUX VETORS P AND Q IN PHYSICAL SPACE       		*
!C   EQUATION () AND ()                              					*
!C***********************************************************************    
  	PP1 = -HY(I,J)
    PP2 = 0.D0
    PP3 = -EZ(I,J)

    QP1 = HX(I,J)
    QP2 = EZ(I,J)
    QP3 = 0.D0                
!C***********************************************************************
!C 	EVALUATION OF THE FLUX VETORS P AND Q IN COMPUTATIONAL SPACE 		*
!C  EQUATION () AND ()                              					*
!C***********************************************************************    
    P1(I,J) = (XIX(I,J)*PP1+XIY(I,J)*QP1)/JJ(I,J)
    P2(I,J) = (XIX(I,J)*PP2+XIY(I,J)*QP2)/JJ(I,J)
    P3(I,J) = (XIX(I,J)*PP3+XIY(I,J)*QP3)/JJ(I,J)

	Q1(I,J) = (ETAX(I,J)*PP1+ETAY(I,J)*QP1)/JJ(I,J)
    Q2(I,J) = (ETAX(I,J)*PP2+ETAY(I,J)*QP2)/JJ(I,J)
    Q3(I,J) = (ETAX(I,J)*PP3+ETAY(I,J)*QP3)/JJ(I,J)
  END DO
END DO

RETURN
END FLUXPQ

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE FLUXINC
!C
!C		THIS SUBROUTINE COMPUTES FLUX VECTORS PI FROM INCIDENT 
!C		E AND H FIELDS
!C
!C 		INPUT  : EZI, HYI
!C 		OUTPUT : P1I, P3I
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE FLUXINC(EZI,HYI,P1I,P3I)

USE ARRAY
USE DOMAIN
USE CURV

IMPLICIT NONE
    
INTEGER :: I

REAL(DP), DIMENSION(IMAX) :: P1I, P3I
REAL(DP), DIMENSION(IMAX) :: EZI, HYI
    
REAL(DP) :: PP1, PP3

DO I = 1,IM
!C***********************************************************************
!C 	 EVALUATION OF THE FLUX SOURCE VETORS PSRC AND QSRC IN PHY. SPACE	*
!C   EQUATION () AND ()                              					*
!C***********************************************************************
  PP1 = -HYI(I)
  PP3 = -EZI(I)
!C***********************************************************************
!C 	 EVALUATION OF THE FLUX SOURCE VETORS PSRC AND QSRC IN COMP. SPACE	*
!C   EQUATION () AND ()                              					*
!C***********************************************************************
  P1I(I) = (XIX(I,1)*PP1)/JJ(I,1)
  P3I(I) = (XIX(I,1)*PP3)/JJ(I,1)
END DO

RETURN
END FLUXINC

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE MRK
!C
!C		THIS SUBROUTINE COMPUTES THE GOVERNING MODEL EQUATION USING
!C		EXPLICIT FOURTH-ORDER MODIFIED RUNGE-KUTTA METHOD
!C
!C 		INPUT  : DZ, EZ, HX, HY, MU, EPSS1, EPSS2, EPS_INF, SIGS, LDT
!C 		OUTPUT : DZ, EZ, HX, HY
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE MRK(N,JJ,DELEZ)

USE DOMAIN
USE CHOICE
USE TFIELDS
USE SOURCE
USE FREESPC
USE NDISPMAT
USE DISPMAT
IMPLICIT NONE

INTEGER :: N
INTEGER :: I,J
REAL(DP), DIMENSION(IMAX,JMAX) :: JJ
REAL(DP), DIMENSION(IMAX) :: P1I, P3I
REAL(DP), ALLOCATABLE, DIMENSION(:,:) :: T1, T2, T3
REAL(DP), ALLOCATABLE, DIMENSION(:,:) :: T1NEW, T2NEW, T3NEW
REAL(DP), ALLOCATABLE, DIMENSION(:,:) :: P1, P2, P3, Q1, Q2, Q3
REAL(DP), ALLOCATABLE, DIMENSION(:,:) :: EZOLD
    
REAL(DP) :: CXI, CETA
REAL(DP) :: DELEZ
REAL(DP) :: PI


ALLOCATE(T1(IMAX,JMAX))
ALLOCATE(T2(IMAX,JMAX))
ALLOCATE(T3(IMAX,JMAX))

ALLOCATE(T1NEW(IMAX,JMAX))
ALLOCATE(T2NEW(IMAX,JMAX))
ALLOCATE(T3NEW(IMAX,JMAX))

ALLOCATE(P1(IMAX,JMAX))
ALLOCATE(P2(IMAX,JMAX))
ALLOCATE(P3(IMAX,JMAX))

ALLOCATE(Q1(IMAX,JMAX))
ALLOCATE(Q2(IMAX,JMAX))
ALLOCATE(Q3(IMAX,JMAX))

ALLOCATE(EZOLD(IMAX,JMAX))

!C***********************************************************************
!C	STORE INITIAL VALUES OF EZ FOR CALCULATION OF DELEZ                 *
!C***********************************************************************
PI 	= DACOS(-1.D0)						! PI VALUE DECLARATION
DELEZ = 0.D0
DO I = 1,IM
  DO J = 1,JM
    EZOLD(I,J)=EZ(I,J)
  END DO
END DO
!C***********************************************************************
!C	BUILD T AND TNEW FROM PRIMITIVE VARIABLES		                    *
!C***********************************************************************
CALL PRIMTOT(JJ,DZ,HX,HY,T1,T2,T3)
CALL PRIMTOT(JJ,DZ,HX,HY,T1NEW,T2NEW,T3NEW)

!C***********************************************************************
!C	CALCULATE COEFFICIENTS IN THE EQUATION  		                    *
!C***********************************************************************
DO I = 2,IM-1
  DO J = 2,JM-1
    CXI  = DT/DXI
    CETA = DT/DETA
  END DO
END DO

!C***********************************************************************
!C  							1ST STAGE					            *
!C***********************************************************************
!C	EVALUATE FLUX TERMS P AND Q FROM E AND H FIELDS						*
!C	EVALUATE T1NEW														*
!C	EVALUATE D FIELDS FROM T1NEW	 									*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C	EVALUATE E FIELDS FROM D FIELDS	 									*
!C***********************************************************************
CALL FLUXPQ(EZ,HX,HY,P1,P2,P3,Q1,Q2,Q3)
DO I = 2,IM-1
  DO J = 2,JM-1
    T1NEW(I,J) = T1(I,J)					 			&
        		 - CXI  * (P1(I,J)-P1(I-1,J)) / 4.D0	&
                 - CETA * (Q1(I,J)-Q1(I,J-1)) / 4.D0
  END DO
END DO
CALL TTOPRIM(JJ,T1NEW,T2NEW,T3NEW,DZ,HX,HY)
CALL BC(DZ,HX,HY)

IF(MATOPT.EQ.1) THEN
  DO I=1,IM
    DO J=1,JM
      EZ(I,J) = DZ(I,J)/EPS(I,J)
    END DO
  END DO
ELSE
  CALL DZTOEZ(DZ,EZ)
ENDIF
!C***********************************************************************
!C  							1ST STAGE					            *
!C***********************************************************************
!C	EVALUATE FLUX TERM P AND Q	FROM E AND H FIELDS						*
!C	EVALUATE T2NEW, T3NEW												*
!C	EVALUATE H FIELDS FROM T2NEW, T3NEW									*
!C	ASSIGN BOUNDARY CONDITIONS											*
!************************************************************************
CALL FLUXPQ(EZ,HX,HY,P1,P2,P3,Q1,Q2,Q3)
DO I = 2,IM-1
  DO J = 2,JM-1
    T2NEW(I,J) = T2(I,J)									&
        		 - CXI  * (P2(I+1,J)-P2(I,J))/4.D0/MU(I,J)	&
                 - CETA * (Q2(I,J+1)-Q2(I,J))/4.D0/MU(I,J)
	T3NEW(I,J) = T3(I,J)						 			&
       			 - CXI  * (P3(I+1,J)-P3(I,J))/4.D0/MU(I,J)	&
                 - CETA * (Q3(I,J+1)-Q3(I,J))/4.D0/MU(I,J)
  END DO
END DO
CALL TTOPRIM(JJ,T1NEW,T2NEW,T3NEW,DZ,HX,HY)
CALL BC(DZ,HX,HY)
!C***********************************************************************
!C  							2ND STAGE					            *
!C***********************************************************************
!C	EVALUATE FLUX TERMS P AND Q FROM E AND H FIELDS						*
!C	EVALUATE T1NEW														*
!C	EVALUATE D FIELDS FROM T1NEW	 									*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C	EVALUATE E FIELDS FROM D FIELDS	 									*
!C***********************************************************************
CALL FLUXPQ(EZ,HX,HY,P1,P2,P3,Q1,Q2,Q3)
DO I = 2,IM-1
  DO J = 2,JM-1
    T1NEW(I,J) = T1(I,J)		 						&
        		 - CXI  * (P1(I,J)-P1(I-1,J)) / 3.D0	&
                 - CETA * (Q1(I,J)-Q1(I,J-1)) / 3.D0

   END DO
END DO
CALL TTOPRIM(JJ,T1NEW,T2NEW,T3NEW,DZ,HX,HY)
CALL BC(DZ,HX,HY)
IF(MATOPT.EQ.1) THEN
  DO I=1,IM
    DO J=1,JM
      EZ(I,J) = DZ(I,J)/EPS(I,J)
    END DO
  END DO
ELSE
  CALL DZTOEZ(DZ,EZ)
ENDIF
!C***********************************************************************
!C  							2ND STAGE					            *
!C***********************************************************************
!C	EVALUATE FLUX TERM P AND Q	FROM E AND H FIELDS						*
!C	EVALUATE T2NEW, T3NEW												*
!C	EVALUATE H FIELDS FROM T2NEW, T3NEW									*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C***********************************************************************
CALL FLUXPQ(EZ,HX,HY,P1,P2,P3,Q1,Q2,Q3)
DO I = 2,IM-1
  DO J = 2,JM-1
    T2NEW(I,J) = T2(I,J)							 		&
       			 - CXI  * (P2(I+1,J)-P2(I,J))/3.D0/MU(I,J)	&
                 - CETA * (Q2(I,J+1)-Q2(I,J))/3.D0/MU(I,J)
    T3NEW(I,J) = T3(I,J)							 		&
       			 - CXI  * (P3(I+1,J)-P3(I,J))/3.D0/MU(I,J)	&
                 - CETA * (Q3(I,J+1)-Q3(I,J))/3.D0/MU(I,J)
  END DO
END DO
CALL TTOPRIM(JJ,T1NEW,T2NEW,T3NEW,DZ,HX,HY)
CALL BC(DZ,HX,HY)
!C***********************************************************************
!C  							3RD STAGE					            *
!C***********************************************************************
!C	EVALUATE FLUX TERMS P AND Q FROM E AND H FIELDS						*
!C	EVALUATE T1NEW														*
!C	EVALUATE D FIELDS FROM T1NEW	 									*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C	EVALUATE E FIELDS FROM D FIELDS	 									*
!C***********************************************************************
CALL FLUXPQ(EZ,HX,HY,P1,P2,P3,Q1,Q2,Q3)
DO I = 2,IM-1
  DO J = 2,JM-1
    T1NEW(I,J) = T1(I,J)					 		 	&
       			 - CXI  * (P1(I,J)-P1(I-1,J)) / 2.D0	&
                 - CETA * (Q1(I,J)-Q1(I,J-1)) / 2.D0
  END DO
END DO
CALL TTOPRIM(JJ,T1NEW,T2NEW,T3NEW,DZ,HX,HY)
CALL BC(DZ,HX,HY)
IF(MATOPT.EQ.1) THEN
  DO I=1,IM
    DO J=1,JM
      EZ(I,J) = DZ(I,J)/EPS(I,J)
    END DO
  END DO
ELSE
  CALL DZTOEZ(DZ,EZ)
ENDIF
!C***********************************************************************
!C  							3RD STAGE					            *
!C***********************************************************************
!C	EVALUATE FLUX TERM P AND Q	FROM E AND H FIELDS						*
!C	EVALUATE T2NEW, T3NEW												*
!C	EVALUATE H FIELDS FROM T2NEW, T3NEW									*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C***********************************************************************
CALL FLUXPQ(EZ,HX,HY,P1,P2,P3,Q1,Q2,Q3)
DO I = 2,IM-1
  DO J = 2,JM-1
    T2NEW(I,J) = T2(I,J)							 		&
       			 - CXI  * (P2(I+1,J)-P2(I,J))/2.D0/MU(I,J)	&
                 - CETA * (Q2(I,J+1)-Q2(I,J))/2.D0/MU(I,J)
	T3NEW(I,J) = T3(I,J)							 		&
       			 - CXI  * (P3(I+1,J)-P3(I,J))/2.D0/MU(I,J)	&
                 - CETA * (Q3(I,J+1)-Q3(I,J))/2.D0/MU(I,J)
  END DO
END DO
CALL TTOPRIM(JJ,T1NEW,T2NEW,T3NEW,DZ,HX,HY)
CALL BC(DZ,HX,HY)
!C***********************************************************************
!C  							4TH STAGE					            *
!C***********************************************************************
!C	EVALUATE FLUX TERMS P AND Q FROM E AND H FIELDS						*
!C	EVALUATE T1NEW														*
!C	ADD SOFT SOURCE/CORRECTION TERM TO T1NEW IN THIS STAGE				*
!C	EVALUATE D FIELDS FROM T1NEW	 									*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C	EVALUATE E FIELDS FROM D FIELDS	 									*
!C***********************************************************************
CALL FLUXPQ(EZ,HX,HY,P1,P2,P3,Q1,Q2,Q3)
DO I = 2,IM-1
  DO J = 2,JM-1
    T1NEW(I,J) = T1(I,J)			 				 	&
       			 - CXI  * (P1(I,J)-P1(I-1,J)) / 1.D0   	&
                 - CETA * (Q1(I,J)-Q1(I,J-1)) / 1.D0
  END DO
END DO

IF(TFSFOPT.EQ.2) THEN
  IF(INCOPT.EQ.1) THEN
    T1NEW(SI,SJ) = T1NEW(SI,SJ) + AMP*DEXP(-0.5D0*(((NT0-N)/TAUW)**2))
  ELSE
    T1NEW(SI,SJ) = T1NEW(SI,SJ) + AMP*DSIN(2*PI*FPEAK*N*DT)
  ENDIF
ELSE
!C	ADD HY CORRECTION TERM TO TOTAL FIELD AT I = IA AND I = IB BOUNDARIES
  DO J = JA,JB
!C	AT I = IA
	T1NEW(IA,J) = T1NEW(IA,J) + CXI * P1I(IA-1)
!C	AT I = IB
	T1NEW(IB,J) = T1NEW(IB,J) - CXI * P1I(IB)
  END DO
ENDIF
CALL TTOPRIM(JJ,T1NEW,T2NEW,T3NEW,DZ,HX,HY)
CALL BC(DZ,HX,HY)
IF(MATOPT.EQ.1) THEN
  DO I=1,IM
    DO J=1,JM
      EZ(I,J) = DZ(I,J)/EPS(I,J)
    END DO
  END DO
ELSE
  CALL DZTOEZ(DZ,EZ)
ENDIF
!************************************************************************
!*  							4TH STAGE					            *
!************************************************************************
!C	EVALUATE FLUX TERM P AND Q	FROM E AND H FIELDS						*
!C	EVALUATE T2NEW, T3NEW												*
!C	EVALUATE INCIDENTS FIELDS											*
!C	ADD CORRECTION TERM TO T2NEW, T3NEW IN THIS STAGE					*
!C	EVALUATE H FIELDS FROM T2NEW, T3NEW									*
!C	ASSIGN BOUNDARY CONDITIONS											*
!************************************************************************
CALL FLUXPQ(EZ,HX,HY,P1,P2,P3,Q1,Q2,Q3)
DO I = 2,IM-1
  DO J = 2,JM-1
    T2NEW(I,J) = T2(I,J)						 			&
        		 - CXI  * (P2(I+1,J)-P2(I,J))/1.D0/MU(I,J)	&
                 - CETA * (Q2(I,J+1)-Q2(I,J))/1.D0/MU(I,J)
	T3NEW(I,J) = T3(I,J)							 		&
       			 - CXI  * (P3(I+1,J)-P3(I,J))/1.D0/MU(I,J)	&
                 - CETA * (Q3(I,J+1)-Q3(I,J))/1.D0/MU(I,J)
  END DO
END DO
!C	EVALUATE SOURCE FIELDS
IF(TFSFOPT.EQ.1) THEN
  CALL INCFIELDCALC(N,JJ,PI,P1I,P3I)
!C	ADDING EZ CORRECTION TERM TO T2NEW, T3NEW IN THE SCATTERED REGION	*
  DO I = IA,IB
!C	AT J = JA-1
    T2NEW(I,JA-1) = T2NEW(I,JA-1) + CETA*(-P3I(I))/MU(I,JA-1)
!C	AT J = JB
    T2NEW(I,JB)   = T2NEW(I,JB) - CETA*(-P3I(I))/MU(I,JB)
  END DO

  DO J = JA,JB
!C	AT I = IA-1
    T3NEW(IA-1,J) = T3NEW(IA-1,J) + CXI*P3I(IA)/MU(IA-1,J)
!C	AT I = IB
    T3NEW(IB,J)   = T3NEW(IB,J) - CXI*P3I(IB)/MU(IB,J)
  END DO
END IF
CALL TTOPRIM(JJ,T1NEW,T2NEW,T3NEW,DZ,HX,HY)
CALL BC(DZ,HX,HY)
    
!C***********************************************************************
!C	CALCULATE DELEZ TO CHECK CONVERGENCE CRITERIA				        *
!C***********************************************************************
DO I = 1,IM
  DO J = 1,JM
    DELEZ = DELEZ + DABS(EZ(I,J)-EZOLD(I,J))*E0
  END DO
END DO

DEALLOCATE(EZOLD)
DEALLOCATE(Q1,Q2,Q3)
DEALLOCATE(P1,P2,P3)
DEALLOCATE(T1,T2,T3)
DEALLOCATE(T1NEW,T2NEW,T3NEW)

RETURN
END SUBROUTINE MRK

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE INCFIELDCALC
!C
!C		THIS SUBROUTINE COMPUTES THE INCIDENT FIELDS USING
!C		EXPLICIT FOURTH-ORDER MODIFIED RUNGE-KUTTA METHOD
!C
!C 		INPUT  : EZI, HYI, LDT
!C 		OUTPUT : EZI, HYI
!C		**NOTE: EZI = DZI IN FREE SPACE
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SUBROUTINE INCFIELDCALC(N,JJ,PI,P1I,P3I)

USE DOMAIN
USE CHOICE
USE IFIELDS
USE SOURCE
IMPLICIT NONE

INTEGER :: N
INTEGER :: I

REAL(DP) :: PI

REAL(DP), DIMENSION(IMAX) :: T1I, T3I
REAL(DP), DIMENSION(IMAX) :: T1IN, T3IN
REAL(DP), DIMENSION(IMAX) :: P1I, P3I
REAL(DP), DIMENSION(IMAX,JMAX) :: JJ
REAL(DP) :: CXI

!C***********************************************************************
!C	BUILD TSRC AND TSRCNEW FROM PRIMITIVE VARIABLES	                    *
!C***********************************************************************
CALL PRIMTOTINC(JJ,EZI,HYI,T1I,T3I)
CALL PRIMTOTINC(JJ,EZI,HYI,T1IN,T3IN)

!C***********************************************************************
!C	CALCULATE COEFFICIENTS IN THE EQUATION  		                    *
!C***********************************************************************
DO I = 2,IM-1
  CXI  = DT/DXI
END DO

!C***********************************************************************
!C  							1ST STAGE					            *
!C***********************************************************************
!C	EVALUATE FLUX TERMS P FROM INCIDENT E AND H FIELDS					*
!C	EVALUATE T1INEW														*
!C	EVALUATE INCIDENT E FIELD FROM T1INEW								*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C	EVALUATE FLUX TERM P AND Q	FROM E AND H FIELDS						*
!C	EVALUATE T3INEW														*
!C	EVALUATE INCIDENT H FIELD FROM T3INEW								*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C***********************************************************************
CALL FLUXINC(EZI,HYI,P1I,P3I)
DO I = 2,IM-1
  T1IN(I) = T1I(I)	- CXI 	* (P1I(I) - P1I(I-1))/4.D0
END DO
CALL TINCTOPRIM(JJ,T1IN,T3IN,EZI,HYI)
CALL FLUXINC(EZI,HYI,P1I,P3I)
DO I = 2,IM-1
  T3IN(I) = T3I(I)	- CXI  * (P3I(I+1) - P3I(I))/4.D0
END DO
CALL TINCTOPRIM(JJ,T1IN,T3IN,EZI,HYI)

!C***********************************************************************
!C  							2ND STAGE					            *
!C***********************************************************************
!C	EVALUATE FLUX TERMS P FROM INCIDENT E AND H FIELDS					*
!C	EVALUATE T1INEW														*
!C	EVALUATE INCIDENT E FIELD FROM T1INEW								*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C	EVALUATE FLUX TERM P AND Q	FROM E AND H FIELDS						*
!C	EVALUATE T3INEW														*
!C	EVALUATE INCIDENT H FIELD FROM T3INEW								*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C***********************************************************************
CALL FLUXINC(EZI,HYI,P1I,P3I)
DO I = 2,IM-1
  T1IN(I) = T1I(I)	- CXI 	* (P1I(I) - P1I(I-1))/3.D0
END DO
CALL TINCTOPRIM(JJ,T1IN,T3IN,EZI,HYI)
CALL FLUXINC(EZI,HYI,P1I,P3I)
DO I = 2,IM-1
  T3IN(I) = T3I(I)	- CXI  * (P3I(I+1)-P3I(I))/3.D0
END DO
CALL TINCTOPRIM(JJ,T1IN,T3IN,EZI,HYI)
!C***********************************************************************
!C  							3RD STAGE					            *
!C***********************************************************************
!C	EVALUATE FLUX TERMS P FROM INCIDENT E AND H FIELDS					*
!C	EVALUATE T1INEW														*
!C	EVALUATE INCIDENT E FIELD FROM T1INEW								*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C	EVALUATE FLUX TERM P AND Q	FROM E AND H FIELDS						*
!C	EVALUATE T3INEW														*
!C	EVALUATE INCIDENT H FIELD FROM T3INEW								*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C***********************************************************************
CALL FLUXINC(EZI,HYI,P1I,P3I)
DO I = 2,IM-1
  T1IN(I) = T1I(I)	- CXI 	* (P1I(I) - P1I(I-1))/2.D0
END DO
CALL TINCTOPRIM(JJ,T1IN,T3IN,EZI,HYI)
CALL FLUXINC(EZI,HYI,P1I,P3I)
DO I = 2,IM-1
  T3IN(I) = T3I(I)	- CXI  * (P3I(I+1)-P3I(I))/2.D0
END DO
CALL TINCTOPRIM(JJ,T1IN,T3IN,EZI,HYI)
!C***********************************************************************
!C  							4TH STAGE					            *
!************************************************************************
!C	EVALUATE FLUX TERMS P FROM INCIDENT E AND H FIELDS					*
!C	EVALUATE T1INEW														*
!C	ADD SOFT SOURCE TO T1INEW											*
!C	EVALUATE INCIDENT E FIELD FROM T1INEW								*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C	EVALUATE FLUX TERM P AND Q	FROM E AND H FIELDS						*
!C	EVALUATE T3INEW														*
!C	EVALUATE INCIDENT H FIELD FROM T3INEW								*
!C	ASSIGN BOUNDARY CONDITIONS											*
!C***********************************************************************
CALL FLUXINC(EZI,HYI,P1I,P3I)
DO I = 2,IM-1
  T1IN(I) = T1I(I)	- CXI 	* (P1I(I) - P1I(I-1))/1.D0
END DO

IF(INCOPT.EQ.1) THEN
  T1IN(SI) = T1IN(SI) + AMP*DEXP(-0.5D0*(((NT0-N)/TAUW)**2))
ELSE
  T1IN(SI) = T1IN(SI) + AMP*DSIN(2*PI*FPEAK*N*DT)
ENDIF

CALL TINCTOPRIM(JJ,T1IN,T3IN,EZI,HYI)
CALL FLUXINC(EZI,HYI,P1I,P3I)
DO I = 2,IM-1
  T3IN(I) = T3I(I) - CXI * (P3I(I+1)-P3I(I))/1.D0
END DO
CALL TINCTOPRIM(JJ,T1IN,T3IN,EZI,HYI)
CALL FLUXINC(EZI,HYI,P1I,P3I)

RETURN
END SUBROUTINE INCFIELDCALC

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE WRITETOFILE
!C
!C		THIS SUBROUTINE WRITES RESULTS TO FILES
!C
!C 		INPUT  : X, Y, EZ, HX, HY
!C 		OUTPUT : RESULTS.DAT
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE WRITETOFILE(N,X,Y,DELEZ,FRAMOPT,OUTFILE,HISTORFILE)

USE DOMAIN
USE TFIELDS
USE FREESPC
USE NDISPMAT
IMPLICIT NONE

INTEGER :: I, J, INCASE
INTEGER :: N, FRAMOPT

REAL(DP) :: DELEZ
REAL(DP), DIMENSION(IMAX,JMAX) :: X, Y
CHARACTER*10 OUTFILE,HISTORFILE
CHARACTER*4 ID
CHARACTER*50 OUTF1, OUTF2, OUTF3, OUTF4

OUTF1='./OUTPUT/'//OUTFILE
OUTF2='./OUTPUT/'//HISTORFILE
WRITE(ID,'(I000)')N
OUTF3='./OUTPUT/X_VAR'//TRIM(ADJUSTL(ID))//'.TXT'
OUTF4='./OUTPUT/FULL_VAR'//TRIM(ADJUSTL(ID))//'.TXT'

OPEN(119,FILE=OUTF1)
!OPEN (UNIT=19,FILE='VAR.TXT',STATUS='REPLACE',ACTION='WRITE',       &
!      IOSTAT=INCASE)
OPEN(129,FILE=OUTF2)
IF(FRAMOPT.EQ.1) OPEN(129,FILE=TRIM(OUTF3))

WRITE(119,1001)IM,JM
1001 FORMAT('IM=',I4,' ;JM=',I4,/)
WRITE(119,*)     
       
WRITE(119,*)'STATE VARIABLES'
WRITE(119,*)
WRITE(119,*)'VARIABLES = "X","Y","EZ","HX","HY","MU","EPS"'
!WRITE(19,*)'NUMBER OF ITERATIONS PERFORMED, N ; '
!WRITE(19,141)N
1002 FORMAT(1X,I8)
1003 FORMAT(5(2X,E16.9E3))
1004 FORMAT(1X,E16.9E3,2(2X,E16.9E3))

DO I = 1,IM
  DO J = 1,JM
    WRITE(109,1003) X(I,J)*LREF,Y(I,J)*LREF,EZ(I,J)*E0,	&
     			    HX(I,J)*E0*DSQRT(EPS0/MU0),			&
                    HY(I,J)*E0*DSQRT(EPS0/MU0)

!    WRITE(129,151) X(I,J)*LREF, Y(I,J)*LREF, EZ(I,J)*E0

  END DO
END DO

WRITE(119,*)
WRITE(119,*)

CLOSE(119)
CLOSE(129)
!CLOSE (19)
!CLOSE (29)
!CLOSE (39)

RETURN
END SUBROUTINE WRITETOFILE

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE PRIMTOT
!C
!C		THIS SUBROUTINE COMPUTES VECTOR T FROM PRIMITIVE VARIABLES
!C
!C 		INPUT  : EZ, HX, HY, JJ
!C 		OUTPUT : T1, T2, T3
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE PRIMTOT(JJ,DZ,HX,HY,T1,T2,T3)

USE DOMAIN
IMPLICIT NONE

INTEGER :: I, J

REAL(DP), DIMENSION(IMAX,JMAX) :: DZ, HX, HY
REAL(DP), DIMENSION(IMAX,JMAX) :: T1, T2, T3
REAL(DP), DIMENSION(IMAX,JMAX) :: JJ

DO I=1,IM
  DO J=1,JM
    T1(I,J) = DZ(I,J)/JJ(I,J)
    T2(I,J) = HX(I,J)/JJ(I,J)
    T3(I,J) = HY(I,J)/JJ(I,J)
  END DO
END DO  

RETURN
END SUBROUTINE PRIMTOT

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE TTOPRIM
!C
!C		THIS SUBROUTINE COMPUTES PRIMITIVE VARIABLES FROM VECTOR T
!C
!C 		INPUT  : T1, T2, T3, JJ
!C 		OUTPUT : EZ, HX, HY
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE TTOPRIM(JJ,T1,T2,T3,DZ,HX,HY)

USE DOMAIN
IMPLICIT NONE

INTEGER :: I, J

REAL(DP), DIMENSION(IMAX,JMAX) :: DZ, HX, HY
REAL(DP), DIMENSION(IMAX,JMAX) :: T1, T2, T3
REAL(DP), DIMENSION(IMAX,JMAX) :: JJ

DO I=1,IM
  DO J=1,JM
    DZ(I,J) = T1(I,J)*JJ(I,J) 
    HX(I,J) = T2(I,J)*JJ(I,J)
    HY(I,J) = T3(I,J)*JJ(I,J)
  END DO
END DO  

RETURN
END SUBROUTINE TTOPRIM

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE PRIMTOTINC
!C
!C		THIS SUBROUTINE COMPUTES VECTOR T FROM PRIMITIVE VARIABLES
!C		(INCIDENT FIELDS)
!C
!C 		INPUT  : EZI, HYI, JJ
!C 		OUTPUT : T1I, T3I
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE PRIMTOTINC(JJ,EZI,HYI,T1I,T3I)

USE DOMAIN
IMPLICIT NONE

INTEGER :: I

REAL(DP), DIMENSION(IMAX) :: EZI, HYI
REAL(DP), DIMENSION(IMAX) :: T1I, T3I
REAL(DP), DIMENSION(IMAX,JMAX) :: JJ

DO I=1,IM
    T1I(I) = EZI(I)/JJ(I,1)
    T3I(I) = HYI(I)/JJ(I,1)
END DO  

RETURN
END SUBROUTINE PRIMTOTINC

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE TINCTOPRIM
!C
!C		THIS SUBROUTINE COMPUTES PRIMITIVE VARIABLES (INCIDENT FIELDS)
!C		FROM VECTOR T
!C
!C 		INPUT  : T1I, T3I, JJ
!C 		OUTPUT : EZI, HYI
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
SUBROUTINE TINCTOPRIM(JJ,T1I,T3I,EZI,HYI)

USE DOMAIN
IMPLICIT NONE

INTEGER :: I

REAL(DP), DIMENSION(IMAX) :: EZI, HYI
REAL(DP), DIMENSION(IMAX) :: T1I, T3I
REAL(DP), DIMENSION(IMAX,JMAX) :: JJ

DO I=1,IM
    EZI(I) = T1I(I)*JJ(I,1)
    HYI(I) = T3I(I)*JJ(I,1)
END DO

RETURN
END SUBROUTINE TINCTOPRIM

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE FOURIERFIELDS
!C
!C		THIS SUBROUTINE COMPUTES THE FOURIER TRANSFORMS OF THE
!C		TOTAL AND INCIDENT EZ FIELD
!C
!C 		INPUT  : N, FM, FREQ, EZ
!C 		OUTPUT : EZF_R, EZF_I
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE FOURIERFIELDS(N,EZ,EZI)

USE DOMAIN
USE FREQVAR
USE FFIELDS
IMPLICIT NONE

INTEGER :: I, J, F
INTEGER :: N

REAL(DP), DIMENSION(IMAX) :: EZI
REAL(DP), DIMENSION(IMAX,JMAX) :: EZ
REAL(DP) :: OMEGA
REAL(DP) :: PI

PI  = DACOS(-1.D0)                      ! PI VALUE DECLARATION

DO F = 1,FM      
  DO I = 1,IM
    DO J = 1,JM

      OMEGA = 2.D0*PI*FREQ(F)*DT
      EZF_R(F,I,J) = EZF_R(F,I,J) + DCOS(OMEGA*N)*EZ(I,J)
      EZF_I(F,I,J) = EZF_I(F,I,J) - DSIN(OMEGA*N)*EZ(I,J)

    END DO        
  END DO
END DO  

DO F = 1,FM
  DO I = 1,IM
    
    OMEGA = 2.D0*PI*FREQ(F)*DT
    INC_R(F,I) = INC_R(F,I) + DCOS(OMEGA*N)*EZI(I)
    INC_I(F,I) = INC_I(F,I) - DSIN(OMEGA*N)*EZI(I)

  END DO
END DO

RETURN
END SUBROUTINE FOURIERFIELDS

!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C						SUBROUTINE TOTALAMPPHASE
!C
!C		THIS SUBROUTINE COMPUTES THE FOURIER AMPLITUDE AND PHASE OF
!C		THE TOTAL AND INCIDENT EZ FIELDS
!C
!C 		INPUT  : EZF_R, EZF_I, INC_R, INC_I
!C 		OUTPUT : EZF_AMP, EZF_PH, INC_AMP, INC_PH
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE AMPPHASE

USE DOMAIN
USE FREQVAR
USE FFIELDS
USE AMPPH

IMPLICIT NONE

INTEGER :: I, J, F

DO F = 1,FM
  DO I = 2,IM-1
    DO J = 2,JM-1

      EZF_AMP(F,I,J) = DSQRT(EZF_R(F,I,J)**2 + EZF_I(F,I,J)**2)
      !EZF_PH(F,I,J)  = DATAN2(EZF_I(F,I,J),EZF_R(F,I,J))

    END DO
  END DO
END DO

DO F = 1,FM
  DO J = 2,JM-1

      INC_AMP(F,J) = DSQRT(INC_R(F,J)**2 + INC_I(F,J)**2)
      !INC_PH(F,I)  = DATAN2(INC_I(F,I),INC_R(F,I))

  END DO
END DO

RETURN
END SUBROUTINE AMPPHASE

!************************************************************************************************************
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!C							  SUBROUTINE WRITEFFTDATA
!C
!C		THIS SUBROUTINE WRITES FREQUENCY DOMAIN DATA TO FILES
!C
!C 		INPUT  : X, Y, 
!C 		OUTPUT : RESULTS.DAT
!C 		+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SUBROUTINE WRITEFFTDATA(N,X,Y)

USE DOMAIN
USE FREESPC
USE FREQVAR
USE FFIELDS
USE AMPPH
IMPLICIT NONE

INTEGER :: I, J, F, INCASE
!INTEGER :: IMID, JMID
INTEGER :: N, FRAMOPT

REAL(DP) :: DELEZ
REAL(DP), DIMENSION(IMAX,JMAX) :: X, Y
CHARACTER*10 OUTFILE,HISTORFILE
CHARACTER*4 ID
CHARACTER*50 OUTF1, OUTF2, OUTF3, OUTF4

!IMID = IDNINT(DBLE(IM+1)/2)
!JMID = IDNINT(DBLE(JM+1)/2)

WRITE(ID,'(I000)')N
FNAME1 = 'FOURIER FIELD'//TRIM(ADJUSTL(ID))//'.DAT'

PRINT*, 'SAVING TO FILE: ',TRIM(FNAME1)

OPEN(UNIT=139,FILE=TRIM(FNAME1),STATUS='REPLACE',ACTION='WRITE',      &
      IOSTAT=INCASE)

WRITE(9,*) 'FOURIER TRANSFORMED ELECTRIC FIELDS IN THE BIOLOGICAL '
WRITE(9,*) 'TISSUE ALONG X-DIRECTION AT FREQUENCY '
WRITE(9,1101)IM,JM,N
WRITE(9,*) 'X, EZ(F), EZSRCZ(F)'

1101 FORMAT('IM=',I4,' ;JM=',I4,' ;STEPS=',I6,/)
1102 FORMAT(3(2X,E16.9E3))

F = 1

DO I = 1,IM

  WRITE(139,1102) X(I,10),EZF_AMP(F,I,10)

END DO

CLOSE(139)

END SUBROUTINE WRITEFFTDATA


!----------------------------------------------------------------------
!---------------------------END OF FILE--------------------------------
